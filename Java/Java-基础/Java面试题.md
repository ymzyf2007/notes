##### 1. 反射中，Class.forName和ClassLoader的区别

答：共同点：1、两者都会将用户指定的类进行加载。

不同点：Class.forName除了将类的.class文件加载到JVM之中之外，还会对类进行解释，执行类中静态块。而ClassLoader只干一件事情，就是将类的.class文件加载到JVM中，不会执行静态块的内容，只有在newInstance才会去执行static块。

##### 2.双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？

答：什么是类加载器？

​		在类加载阶段，有一步是“通过类的全限定名来获取描述此类的二进制字节流”，而所谓的类加载器就是实现这个功能的一个代码模块，这个动作是在Java虚拟机外部实现的，这样做可以让应用程序决定自己如何去获取所需要的类。

​		类加载器的作用：首先类加载器可以实现最本质的功能即类的加载动作。同时，还能够结合Java类本身来确定该类在Java虚拟机的唯一性。用通俗的话来说就是：比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义；否则这两个类是源于同一个class文件，只要加载他们的类加载器不同，那么这两个类必定不相等。

**双亲委派模型**

​		从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外，并且全部继承抽象类java.lang.ClassLoader。

​		从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：

1）启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM中，如果名称不符合的类库即便放在lib目录也不会被加载。该类加载器无法被Java程序直接饮用。

2）扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\ext目录下的类库，但是貌似在JDK的安装目录下，没看到该指定的目录。该加载器可以被开发者直接使用。

3）应用程序类加载器（Application ClassLoader）：该加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。

​		我们的应用程序都是由这三类加载器互相配合进行加载的，我们也可以加入自己定义的类加载器。

​		类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承的关系实现，而是通过组合关系来复用父加载器的代码。

​		双亲委派模型的工作流程为：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父类加载器反馈自己无法完成该加载请求（该类加载器的搜索范围没有找到对应的类）时，子类加载器才会尝试去加载。**

##### 3.有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？

答：可以的，因为双亲委派模型并不是一个强制性的约束模型，但是父类加载器加载出来的类和子类加载器加载出来的类就不是同一个类了。比较两个类是否相等，只有这两个类是同一个类加载器加载才有意义，否则，即使这两个类都是来源同一个class文件，只要它们的类加载器不同，那么这两个类必定不相等。

##### 4.Java的内存模型（Java虚拟机的区域如何划分，每一个区的功能）以及GC算法。

答：Java虚拟机在执行Java程序过程中会把它管理的内存划分成很多个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动、结束而建立和销毁。Java虚拟机管理的内存划分为以下几个区域：

**1）程序计数器（Program Counter Register）**：程序计数器是比较小的内存空间，它的作用是当前线程所执行的字节码的行数指示器。它是线程私有的，即各个线程都有独立的程序计数器。此内存区域是唯一的一个不会抛出OutOfMemoryError异常的区域。

**2）Java虚拟机栈（Java Virtual Machine Stacks）**：Java虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作栈、动态链接，方法出口等信息。每一个方法被调用直到执行完成的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。Java虚拟机栈也是线程私有的，生命周期也跟线程相同。

局部变量表存放的类型包括以下三种：

1、编译期可知的基本数据类型：boolean、byte、char、short、int、float、long、double共8种类型；

2、对象引用：即reference类型，它存放的是一个指向堆中对象起始地址的引用指针，或一个代表对象的句柄或者其他与此对象相关的位置，根据虚拟机的不同实现而不同；

3、returnAddress类型：存放指向一条字节码指令的地址；

Java虚拟机栈会抛出两种异常：

1、OutOfMemoryError异常：如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时抛出；

2、StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度时抛出；

**3）、本地方法栈（Native Method Stacks）**

本地方法栈与虚拟机栈的作用相似，它是虚拟机在执行native方法时服务，而虚拟机栈是为虚拟机执行java方法服务。此内存区域也会抛出OutOfMemoryError异常和StackOverflowError异常。

**4）、Java堆（Java Heap）**

Java堆是用于存放对象实例和数组。它是java虚拟机管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建，也是垃圾收集器管理的主要区域，几乎所有的对象实例都在这里分配内存。

**5）、方法区**

方法区用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它是堆的一个逻辑部分，是各个线程共享的内存区域

GC算法：

1）、引用计数算法：每个对象计算指向它的指针的数量。需要时间上和空间上开销。最大的缺点是无法处理环形引用。

2）、标记-清除（Mark-Sweep）算法：是对所有存活的对象进行一次全局扫描来确定哪些对象可以回收，遍历是从根出发，找到所有可达对象，除此之外，不可达对象就是垃圾对象，可以被回收。















































