##### 1. 反射中，Class.forName和ClassLoader的区别

答：共同点：1、两者都会将用户指定的类进行加载。

不同点：Class.forName除了将类的.class文件加载到JVM之中之外，还会对类进行解释，执行类中静态块。而ClassLoader只干一件事情，就是将类的.class文件加载到JVM中，不会执行静态块的内容，只有在newInstance才会去执行static块。

##### 2.双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？

答：什么是类加载器？

​		在类加载阶段，有一步是“通过类的全限定名来获取描述此类的二进制字节流”，而所谓的类加载器就是实现这个功能的一个代码模块，这个动作是在Java虚拟机外部实现的，这样做可以让应用程序决定自己如何去获取所需要的类。

​		类加载器的作用：首先类加载器可以实现最本质的功能即类的加载动作。同时，还能够结合Java类本身来确定该类在Java虚拟机的唯一性。用通俗的话来说就是：比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义；否则这两个类是源于同一个class文件，只要加载他们的类加载器不同，那么这两个类必定不相等。

**双亲委派模型**

​		从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外，并且全部继承抽象类java.lang.ClassLoader。

​		从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：

1）启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM中，如果名称不符合的类库即便放在lib目录也不会被加载。该类加载器无法被Java程序直接饮用。

2）扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\ext目录下的类库，但是貌似在JDK的安装目录下，没看到该指定的目录。该加载器可以被开发者直接使用。

3）应用程序类加载器（Application ClassLoader）：该加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。

​		我们的应用程序都是由这三类加载器互相配合进行加载的，我们也可以加入自己定义的类加载器。

​		类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承的关系实现，而是通过组合关系来复用父加载器的代码。

​		双亲委派模型的工作流程为：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父类加载器反馈自己无法完成该加载请求（该类加载器的搜索范围没有找到对应的类）时，子类加载器才会尝试去加载。**

##### 3.有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？

答：可以的，因为双亲委派模型并不是一个强制性的约束模型，但是父类加载器加载出来的类和子类加载器加载出来的类就不是同一个类了。比较两个类是否相等，只有这两个类是同一个类加载器加载才有意义，否则，即使这两个类都是来源同一个class文件，只要它们的类加载器不同，那么这两个类必定不相等。

##### 4.Java的内存模型（Java虚拟机的区域如何划分，每一个区的功能）以及GC算法。

答：Java虚拟机在执行Java程序过程中会把它管理的内存划分成很多个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动、结束而建立和销毁。Java虚拟机管理的内存划分为以下几个区域：

**1）程序计数器（Program Counter Register）**：程序计数器是比较小的内存空间，它的作用是当前线程所执行的字节码的行数指示器。它是线程私有的，即各个线程都有独立的程序计数器。此内存区域是唯一的一个不会抛出OutOfMemoryError异常的区域。

**2）Java虚拟机栈（Java Virtual Machine Stacks）**：Java虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作栈、动态链接，方法出口等信息。每一个方法被调用直到执行完成的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。Java虚拟机栈也是线程私有的，生命周期也跟线程相同。

局部变量表存放的类型包括以下三种：

1、编译期可知的基本数据类型：boolean、byte、char、short、int、float、long、double共8种类型；

2、对象引用：即reference类型，它存放的是一个指向堆中对象起始地址的引用指针，或一个代表对象的句柄或者其他与此对象相关的位置，根据虚拟机的不同实现而不同；

3、returnAddress类型：存放指向一条字节码指令的地址；

Java虚拟机栈会抛出两种异常：

1、OutOfMemoryError异常：如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时抛出；

2、StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度时抛出；

**3）、本地方法栈（Native Method Stacks）**

本地方法栈与虚拟机栈的作用相似，它是虚拟机在执行native方法时服务，而虚拟机栈是为虚拟机执行java方法服务。此内存区域也会抛出OutOfMemoryError异常和StackOverflowError异常。

**4）、Java堆（Java Heap）**

Java堆是用于存放对象实例和数组。它是java虚拟机管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建，也是垃圾收集器管理的主要区域，几乎所有的对象实例都在这里分配内存。

**5）、方法区**

方法区用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它是堆的一个逻辑部分，是各个线程共享的内存区域

GC算法：

1）、引用计数算法：每个对象计算指向它的指针的数量。需要时间上和空间上开销。最大的缺点是无法处理环形引用。

2）、标记-清除（Mark-Sweep）算法：是对所有存活的对象进行一次全局扫描来确定哪些对象可以回收，遍历是从根出发，找到所有可达对象，除此之外，不可达对象就是垃圾对象，可以被回收。

##### 5.Java中的队列都有哪些，有什么区别。

答：Queue（队列）、Deque（双端队列）、BlockingQueue（阻塞队列）。阻塞队列与一般队列的区别是，将元素添加到队列时，如果队列已满会一直阻塞。取元素时，如果队列为空一直阻塞。

##### 6.Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高。

答：数组：查找和遍历效率高；链表：插入和删除效率高

##### 7.什么是死锁？JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？

答：死锁是指多个线程执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象。若无外力作用，它们都将无法进行下去。可以用jps、jstack或VisualVM排查原因。
     VisualVM包括了jstat，jconsole，jmap和jinfo，可以使用VisualVM生成和分析海量数据、跟踪内存泄露，监控垃圾回收器。
     Dump线程包含有线程状态，runnable，blocked等，可以看到线程持有什么监控对象等。需要哪些监控对象等。

##### 8.查看jvm虚拟机里面堆、线程的信息，你用过什么命令？

答：jps：列出当前用户的所有java线程。

​		jstack：用于打印出给定的java进程ID的堆栈信息。

​		jmap：打印出给定java进程内存内的所有对象。

##### 9.Java中HashMap实现原理，get()，put()是如何实现的？HashMap有哪些问题？

答：HashMap其实也是用一个线性数组实现的。它是一个链表散列的数据结构，即数组和链表的结合体。
     首先HashMap里面有个Entry内部类，其重要的属性有key，value和next。HashMap的基础就是一个线性数组，这个数组就是Entry<K, V>[]。保存到Map的内容都是保存在Entry数组里面。
     HashMap中的get(key)是这样实现的，首先是获取key的哈希值（hashcode），再把hashcode通过一个散列运算得到一个int类型的h值。得到这个int类型的值之后，然后拿这个值与HashMap的承载量（HashMap的默认承载量length是16，可以自动变长）进行逻辑与运算，这样得到一个比HashMap的长度小的正数。这样得到就是要获取的值在数组中存储的位置。然后遍历这个位置上的元素，找到hashcode相同并且两个对象equals时，返回value。
     HashMap中的put(k, v)是这样实现的，首先是获取key的哈希值（hashcode），再把hashcode通过一个散列运算得到一个int类型的h值。得到这个int类型的值之后，然后拿这个值与HashMap的承载量（HashMap的默认承载量length是16，可以自动变长）进行逻辑与运算，这样得到一个比HashMap的长度小的正数。这样得到就是要存储的在数组中存储的位置。先判断该位置上有没有元素，没有的话就创建一个Entry对象，在这个位置上插入，这样插入结束；如果有的话，通过对链表的遍历，判断是否已经存在key（判断hashcode和equals），有的话用新的value值代替老的value值；如果没有，则在该位置插入Entry对象，把原来该位置的Entry赋值给新的Entry的next节点，这样插入结束。
     HashMap的问题是线程安全问题，它不是线程安全的，它是非一致性哈希的实现。resize会导致映射关系的重大变化。

##### 10.ConcurrentHashMap的get()，put()，又是如何实现的？ConcurrentHashMap有哪些问题？ ConcurrentHashMap的锁是读锁还是写锁？

答：ConcurrentHashMap是允许多个修改操作并发进行，只要这些修改操作在不同的段上。ConcurrentHashMap使用了锁分离技术。ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。

ConcurrentHashMap的get操作是直接委托给段（Segment）的get方法的，get操作是不需要加锁的。

ConcurrentHashMap的put操作是直接委托给段（Segment）的put方法的，put方法是段加锁。

ConcurrentHashMap的是写锁。

ConcurrentHashMap的问题：如果你只调用get()，或只调用put()时，ConcurrentHashMap是线程安全的。但是在一个方法里面你调用完get()之后，调用put之前，有另一个线程调用了put，你再去执行put，这样就可能把前面的操作结果覆盖掉了。所以，即使在线程安全的情况下， 还是违反了原子操作。

##### 11.HashMap与HashTable的区别

答：

1）、继承不同，HashMap是继承AbstractMap，而Hashtable是继承Dictionary。

2）、Hashtable中的方法是同步的，即是线程安全的，而HashMap是线程不全的。

3）、Hashtable中，key和value都不允许出现null值。而HashMap中，null可以作为键，这样的键这有一个；可以有一个或多个键所对应的值null。

4）、哈希值的使用不用，Hashtable直接使用对象的hashCode，而HashMap获取hashCode后重新根据散列运算得到位置值。

5）、Hashtable和HashMap它们两个内部实现方式的数组的初始化大小和扩容方式不一样。

##### 12.HashSet实现原理

答：HashSet实现Set接口，由哈希表支持。它不保证set的迭代顺序：特别是它不保证该顺序恒久不变。

​		此类允许用null元素。HashSet中不允许有重复元素，这是因为HashSet是根据HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object(); HashSet跟HashMap一样，都是一个存放链表的数组。

##### 13.判断两个对象是否相等，为什么必须同时重写equals()和hashcode()方法

答：hashcode顾名思义是一个散列值码。散列值，并不能表现其唯一性，但是具有离散性，其意义在于类似进行hashMap等操作时，加快对象比较的速度，进而加快对象搜索的速度。

​		hashcode和equals的关系

​		两个对象equals的时候，hashcode必须相等，但hashcode相等时，对象不一定equals。

​		在java中，equals和hashcode是有设计要求的，equals相等，则hashcode一定相等，反之则不然。

 		为什么会有这样的要求呢？

​		在集合中，比如HashSet中，要求放入的对象不能重复，怎么判定呢？

​		首先会调用hashcode，如果hashcode相等，则继续调用equals，如果equals也相等，则认为重复。

​		如果只重写了equals方法而没有重写hashcode方法，则hashcode就是继承Object的，返回内存编码，这时候可能出现equals相等，但是hashcode不等的情况。你的对象 使用集合时就会得不到你想要的结果。

​		最后明白两点就行了：

1）、hashCode()方法存在的主要目的就是提高效率。

2）、在集合中判断两个对象相等的条件，其实无论是往集合中存储数据，还是从集合中取数据，包括控制唯一性等，都是用这个条件判断的，条件如下：

​		首先判断两个对象的hashcode是否相等，如果不相等，就认为这两个对象不相等，就完成了。如果相等，才会判断两个对象的equals()方法是否相等，如果不相等，就认为两个对象不相等，如果相等，那就认为这两个对象相等。

##### 14.什么是一致性哈希？用来解决什么问题？

答：一致性哈希是在哈希算法的基础上，提出的在动态变化的分布式环境中，一致性哈希要满足几个条件，平衡性、单调性和分散性。（提供一个hashtable，它能使节点加入或离去的时候，不会导致哈希映射重大改变）

​		平衡性是指 hash的结果应该平均分配到各个节点, 这样从算法上就解决了负载均衡问题。

​		单调性是指在新增或者删减节点时, 同一个key访问到的值总是一样的。

​		分散性是指数据应该分散的存放在分布式集群中的各个节点(节点自己可以有备份)，不必要每个节点都存储所有的数据。

​		用来解决分布式数据存储系统，负载均衡。（memcached的客户端，使用了一致性hash算法ketama进行数据存储节点的选择）。















































