​		本文主要讨论这么几个问题：

（1）AOP成员

（2）AOP实现机制

（3）AOP到底能做什么

（4）Spring的AOP

##### 一、AOP成员

joinpoint：拦截点，比如方法等

pointcut：切入点，joinpoint的表达式，一个pointcut对应多个joinpoint

target：目标对象

proxy：代理对象

advice：通知，要切入的逻辑

​	前置通知

​	后置通知

​	环绕通知

​	返回通知

​	异常通知

aspect：切面，包含pointcut和advice

weaver：织入器通过切面中定义的pointcut来搜索目标（被代理类）的joinpoint（拦截点），然后把要切入的逻辑（advice）织入到目标对象里，生成代理类。

##### 二、AOP实现机制

（1）、JDK动态代理

​		动态代理在运行期通过接口动态生成代理类，这为其带来了一定的灵活性，但这个灵活性却带来两个问题，第一代理类必须实现一个接口，如果没实现接口会抛出一个异常。第二性能影响，因为动态代理使用反射机制实现的，首先反射肯定比直接调用要慢，其次使用反射大量生成类文件可能引起Full GC造成的性能影响，因为字节码文件加载后会存放在JVM运行时区的方法区（或者叫持久代），当方法区满的时候，会引起Full GC。

（2）、动态字节码生成

​		cglib实现aop原理是在运行期间目标字节码加载后，生成目标类的子类，再将切面逻辑加入到子类中，所以cglib实现aop不需要基于接口。

##### 三、AOP到底能做什么

（1）、性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警

（2）、记录日志，在方法执行前后记录系统日志

（3）、权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常

##### 四、Spring的AOP

​		Spring默认采用的动态代理机制实现AOP，当动态代理不可用时（代理类无接口）会使用cglib机制。但Spring的AOP有一定的缺点，第一个只能对方法进行切入，不能对接口，字段，静态代码块进行切入。第二个性能不是太好。