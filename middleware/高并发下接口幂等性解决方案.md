##### 一、幂等性概念

我的理解：幂等就是一个操作，无论执行多少次，产生的效果和返回的结果都是一样的。

##### 二、幂等性场景

1、查询操作：查询一次和查询多次，在数据不变的情况下，查询结果都是一样的。select是天然的幂等操作。

2、删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。（注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果是多个）。

3、唯一索引：防止新增脏数据。要点：唯一索引或唯一组合索引来防止新增脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该存在了，返回结果即可）。

4、token机制：防止页面重复提交。原理上是通过session token来实现的（也可以通过redis来实现）。当客户端请求页面时，服务器会生成一个随机数token，并将token设置到session中（或者是redis中），然后将token发给客户端（一般通过构造hidden表单），下次客户端提交请求时，token会随着表单一起提交到服务端。服务端第一验证相同后，会将session中的token值更新下，若用户重复提交，第二次及以后的验证判断将失败，因为用户提交的表单中的token值没变，但服务端session中token已经改变了。

5、悲观锁

获取数据的时候加锁获取。select * from table_name where id='xxx' for update;注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的；悲观锁使用时一般会伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。

6、乐观锁

乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式可以通过数据版本version来实现。

1）通过版本号实现

update table_name set data='', version=version+1 where version=version;

7、分布式锁

redis：setex key value expiretime  设置成功即获取锁成功，然后执行业务代码，然后删除key。

zookeeper：

1）在/lock目录下创建临时有序节点（ephemeral_sequential）

2）客户端获取/lock目录下的所有子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则表示获取锁成功，否则监听比自己大最小的节点监听删除事件。

3）如果获取锁成功则执行业务代码

4）完成业务后，删除对应的子节点来释放锁。